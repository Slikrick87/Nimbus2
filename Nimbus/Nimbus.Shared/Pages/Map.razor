@using Nimbus.Shared.Logic
@using Nimbus.Shared.Services;
@using Nimbus.Shared.Entities;
@using Nimbus.Shared.Repositories;
@using Nimbus.Shared.Pages;
@using Microsoft.Maui.Devices.Sensors;
@using System.Linq;
@using System.Text.Json;
@using Microsoft.JSInterop;
@using System.Diagnostics

@page "/map"

@inject IRouteRepository RouteRepository
@inject IAddressRepository AddressRepository
@inject IGeoLocationService GeoLocationService
@inject SelectionService SelectionService
@inject IJSRuntime JS

<h3>Map</h3>
<div id="map" style="height:500px;width:100%;"></div>

<!-- Load Maps API without a callback (avoid automatic call to a missing initMap) -->
<script async defer src="https://maps.googleapis.com/maps/api/js?key=@Keys.mapsKey&libraries=marker"></script>
<!-- helper script - correct static asset path for a library embedded in the Nimbus.Shared project -->
<script defer src="_content/Nimbus.Shared/googleMapsWaypoints.js"></script>

<table class="table">
    @if (SelectionService.selectedRoute != null && SelectionService.selectedRoute.stops != null && SelectionService.orderedStopsForRoute != null)
    {
        <thead>
            <tr>
                <th>Order #</th>
                <th>Street Number</th>
                <th>Street Name</th>
                <th>City</th>
                <th>State</th>
                <th>Zip Code</th>
            </tr>
        </thead>
        <tbody>
            @foreach (var tuple in SelectionService.orderedStopsForRoute.Select((stop, i) => new { stop, i }))
            {
                <tr>
                    <td>@(tuple.i + 1)</td>
                    <td>@tuple.stop.streetNumber</td>
                    <td>@tuple.stop.streetName</td>
                    <td>@tuple.stop.city</td>
                    <td>@tuple.stop.state</td>
                    <td>@tuple.stop.zipCode</td>
                    <td>
                        <button type="button"
                                style="background-color:#D98A4A;color:#000000;border:none;padding:6px 10px;border-radius:4px"
                                @onclick="() => MoveUp(tuple.i)">
                            Up
                        </button>
                    </td>
                    <td>
                        <button type="button"
                                style="background-color:#2447FF;color:#FFFFFF;border:none;padding:6px 10px;border-radius:4px"
                                @onclick="() => MoveDown(tuple.i)">
                            Down
                        </button>
                    </td>
                </tr>
            }
        </tbody>
    }
</table>

@code {
    public class GeoCodeResult { public double lat { get; set; } public double lng { get; set; } }
    List<GeoCodeResult> locationsGeoCode = new List<GeoCodeResult>();

    private async Task EnsureMapsWaypointsLoadedAsync(int timeoutMs = 4000)
    {
        var sw = System.Diagnostics.Stopwatch.StartNew();
        while (sw.ElapsedMilliseconds < timeoutMs)
        {
            try
            {
                var exists = await JS.InvokeAsync<bool>("eval", "typeof window.mapsWaypoints !== 'undefined'");
                if (exists) return;
            }
            catch
            {
                // transient - keep waiting
            }
            await Task.Delay(120);
        }
        throw new InvalidOperationException("mapsWaypoints script not loaded (timeout).");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        try
        {
            await GetAddressesAndGeocode();

            var locations = SelectionService.orderedStopsForRoute
                .Where(a => a.Lat.HasValue && a.Lng.HasValue)
                .Select((a, i) => new { lat = a.Lat.Value, lng = a.Lng.Value, label = $"{a.streetNumber} {a.streetName}", index = i })
                .ToList();

            var locationsJson = JsonSerializer.Serialize(locations);

            // wait for the helper to be available
            await EnsureMapsWaypointsLoadedAsync();

            // call the helper by its global name
            await JS.InvokeVoidAsync("mapsWaypoints.initMap", "map", locationsJson, new { zoom = 14, mapId = "DEMO_MAP_ID", accentVar = "--app-accent" });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
        }
    }

    public async Task GetAddressesAndGeocode()
    {
        if (SelectionService.selectedRoute != null)
        {
            var addresses = AddressRepository.GetAddressesByRoute(SelectionService.selectedRoute.Id);

            foreach (var address in addresses)
            {
                try
                {
                    var formattedAddress = $"{address.streetNumber} {address.streetName}, {address.city}, {address.state} {address.zipCode}";
                    Debug.WriteLine($"Geocoding: {formattedAddress}");

                    await EnsureMapsWaypointsLoadedAsync();
                    var jsonLatLng = await JS.InvokeAsync<string>("mapsWaypoints.geocodeAddress", formattedAddress);
                    var location = JsonSerializer.Deserialize<GeoCodeResult>(jsonLatLng);
                    address.Lng = location.lng;
                    address.Lat = location.lat;
                }
                catch (Exception ex) { Debug.WriteLine($"Coordinate retrieval unsuccessful: {ex.Message}"); }
            }
        }
    }
    private async Task MoveUp(int key)
    {
        if (key <= 0) return;
        try
        {
            var stops = SelectionService.orderedStopsForRoute;
            var temp = stops[key];
            stops[key] = stops[key - 1];
            stops[key - 1] = temp;
            await SelectionService.ReorderStopsForRoute(stops);
            StateHasChanged();
            await UpdateMap();
        }
        catch (Exception ex) { Debug.WriteLine($"Error moving stop up: {ex.Message}"); }
    }
    private async Task MoveDown(int key)
    {
        if (key < 0 || key >= SelectionService.orderedStopsForRoute.Count - 1) return;
        try
        {
            var stops = SelectionService.orderedStopsForRoute;
            var temp = stops[key];
            stops[key] = stops[key + 1];
            stops[key + 1] = temp;
            await SelectionService.ReorderStopsForRoute(stops);
            StateHasChanged();
            await UpdateMap();
        }
        catch (Exception ex) { Debug.WriteLine($"Error moving stop down: {ex.Message}"); }
    }
    private async Task UpdateMap()
    {
        await GetAddressesAndGeocode();
        var locations = SelectionService.orderedStopsForRoute
            .Where(a => a.Lat.HasValue && a.Lng.HasValue)
            .Select((a, i) => new { lat = a.Lat.Value, lng = a.Lng.Value, label = $"{a.streetNumber} {a.streetName}", index = i })
            .ToList();

        var locationsJson = JsonSerializer.Serialize(locations);
        await JS.InvokeVoidAsync("mapsWaypoints.initMap", "map", locationsJson, new { zoom = 14, mapId = "DEMO_MAP_ID", accentVar = "--app-accent" });
    }

    public async Task GetLocationFromDeviceAsync()
    {
        Location currentLocation = await GeoLocationService.GetLocationAsync();
    }
    public async Task<string> GetLatLong()
    {
        try
        {
            return AddressRepository.ConvertToJSAddressByRoute(SelectionService.selectedRoute.Id).AsyncState.ToString();
        }
        catch (Exception ex)
        {
            return "lat: 37.7749, lng: -122.4194";
        }
    }
    public async Task WindowOpen(Address stop)
    {
        var json = await JS.InvokeAsync<string>("mapsWaypoints.geocodeAddress", $"{stop.streetNumber} {stop.streetName}, {stop.city}, {stop.state} {stop.zipCode}");
        var location = JsonSerializer.Deserialize<GeoCodeResult>(json);
        var url = $"https://www.google.com/maps/dir/?api=1&destination={location.lat},{location.lng}";
        await JS.InvokeVoidAsync("open", url, "_blank");
    }
}